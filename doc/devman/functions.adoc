= f.functions

This document will describe how functions get written and dispatched.  It
should be a useful reference when you intend to add a new function, or
understand how the code works.


== Conventions

Unless otherwise stated, most mentions of "`f.function`" (in singular or
plural) are meant to be generic references to any `f.anything` that ctwm
implements, rather than specifically the `f.function` function.  This is
done because just calling them "`functions`" is awful ambiguous,
especially when talking about the implementation, because the
implementation of a ctwm _function_ is done in terms of a C _function_,
so there's _huge_ opportunity for terminological confusion.


== Functional Considerations

There are a few choices in the way functions work to consider in any
given case.

=== Arguments

Some functions take an argument, while others don't.  For example, the
case of <<example-gotoworkspace>> as described below takes an argument,
so you'd have something like `f.gotoworkspace "one"` in a key binding or
menu.  Contrarily, <<example-identify>> doesn't, so you'd merely have
`f.identify` in the config.

This is controlled by a column in the `function_defs.list` file; see
below where the <<impl-functions-defs-sections>> are discussed.

[[cons-deferral,Deferral]]
=== Deferral

There is also a concept of _function deferral_.  This happens in the case
of functions that in some way target a window (`f.move` and friends,
`f.resize`, `f.occupy`, and a great many others).  When you activate them
from a mouse/key binding or titlebar icon or the like, ctwm can see which
window you're pointing at, and targets it from there.  However, when run
from a menu, you can't be pointing at a window; you're pointing at the
menu.

As a result, ctwm _defers_ the execution of the function.  It changes the
mouse cursor to something to prod the user, and waits for you to click on
a window.  _Then_ it runs back into the function execution to actually to
the work.

So any function that has to do something related to a window has to be
setup to defer, or it won't work from a menu.  This is also controlled in
`functions_defs.list`; x-ref the description of the
<<impl-functions-defs-sections>>.  The right cursor for any given case is
a matter of judgement, but generally move/resize actions have one cursor
(the `DC_MOVE` choice), and other functions use the other (`DC_SELECT`).

=== Magic and Internal

Magic stuff like `f.function`.  Gloss of internal-only funcs that you're
probably not touching.


== Implementation Overview

Much over the overall control for dispatching and finding functions is
done via generated code, from the definitions in `functions_def.list`.
f.function execution begins by calling into the `ExecuteFunction()`
function from various places (usually event handlers for menu selections
or mouse/key bindings, but there are a few other ways).  There it uses
various of the autogenerated bits to look up what sort of deferral or
other magic it might do, and then falls down into individual C functions
for implementing each ctwm f.function.

=== `functions_defs.list` and autogenerated controls.

As part of the build process, `tools/mk_function_bits.sh` builds various
generated header files (_i.e._, `build/functions_*.h`) from the
`functions_defs.list` file.  Comments in that file give a good reference
to the details of the syntax.  We'll skim the higher-level overview here.

[[impl-functions-defs-sections,functions_defs.list sections]]
==== Sections

There are 3 sections in the file, delineated by comments like
`#START(section)` and `#END(section)`; these are used as markers by the
`mk_function_bits.sh` script to find the bits it needs at any given time.

The `aliases` and `synthetic` section are almost certainly not anything
you need to touch.  `aliases` are alternate names for functions.  Those
that exist are historical, and we should probably avoid adding any new
ones; just name a function what it should be named, and don't add
confusion by having multiple names.  `synthetic` are functions not
exposed to the user (_i.e._, not available in config files) but get
called from things like the magic `TwmWindow` menu.  Both are very
special cases, so unless you're doing something very unusual, you'll
never go near them.

The `main` section is where you'll be playing.  It contains space
delimited columns (mostly visually lined up in the file for convenience;
the script only cares about whitespace).  First is the name; obvious.
Second determines whether it's a function that takes an argument (like
<<example-gotoworkspace>> below) or one that doesn't.

The third column defines the deferral cursor; this has the side effect of
determining whether it's a deferred function or not; see discussion of
<<cons-deferral>> above.
And the fourth allows hiding info about the function
behind an #ifdef.  The only current use of that is for the rplay-based
sound support, and it should probably be avoided for new functions.
Generally, the function should be available all the time, and just do
nothing (or beep, or something appropriate) when the condition code
isn't available.  This saves users from some complication in writing
their config files.

==== Generated Files

From that, `mk_function_bits.sh` generates header files that contain the
various info about the functions.

* One file contains the ``#define``'s for all the `F_WHATEVER` contants
used in the code to refer to the f.functions internally.  This only
really needs the names.

* It also generates the `funckeytable` lookup table the config file
parser (in `parse_keyword()`) uses to look up the functions referred to
in the config table.  This needs the second column to distinguish
functions taking argument from those that don't.  It also uses bits from
the `aliases` section, since we need to parse those names when give (and
treat them the same as the real f.function names).

* It generates the `fdef_table` lookup table which is used in the
f.function execution (in `EF_main()`) to determine whether to defer
calling the function, and what X cursor to set when it defers.  This uses
the third column (and only includes f.functions that have something
there).  See earlier discussion of <<cons-deferral>>.

* And finally, it generates the `func_dispatch` table used in `EF_main()`
to dispatch the actual execution of the f.function to the underlying C
function that implements it.  This is just built off the names.

=== Dispatching and Executing

Some mechanism (usually invocation from menu or button/key binding) calls
some f.function.  This calls into `ExecuteFunction()` to do the
dispatching, which is just an external thunk into `EF_main()`.  This
checks the environment and the `fdef_table` we generated to determine
whether the function should be deferred; if so, it sets the deferral
cursor and returns.  Actual execution then happens via another fresh call
into `ExecuteFunction()` via slightly creepy magic in the `ButtonPress`
event handling code.  You don't want to know.

Then it falls into actually dispatching the function.  There are two
special cases described below.  Most f.functions simply run through to an
individual C function that implements them, via the `func_dispatch` table
and specific naming; the implemetation of the ctwm function `f.abcdef`
will be in the C function `f_abcdef_impl()`.

The two special cases revolve around the `f.function` construction which
allows user creation of ctwm functions that alias or chain multiple other
f.functions (x-ref `Function` keyword in the user name).  The first is
`f.function` itself, which loops over the list of things the user told it
to do and recurses back into `EF_main()` for them.  The second is the
magic `f.deltastop` (which is only meaningful as part of a
``f.function``'s chain), which checks its magic and returns a value from
`EF_main()` to tell the calling `f.function` invocation to stop where it
is instead of proceeding.  _This is the only use of ``EF_main()``'s
return value_.


== Implementating A Function

Most of the work of implementing a new f.function should be whatever code
you actually need to write to _do_ what the function is supposed to do.
We want to minimize the boilerplate you need to do to hook it up.

Generally, you only need to do two things:

. Add it to the `main` section of the `functions_defs.list` file, with
whatever options are appropriate.  The build system will notice the
change and add it to the generated files next time you build.  Then it's
ready to be parsed from a config file and executed at runtime.  Note that
this will cause a compile failure until you also

. Create the implementation in the appropriately named C function.  The
`DFHANDLER()` macro exists to set the right name and argument list; use
it instead of trying to do it manually.  Even an empty function will be
enough to satify the compiler and get you running.


== Implementation Examples

[[example-identify,f.identify]]
=== `f.identify` and `f.version`

Window targetting vs. not and deferral.  Shared backend.

[[example-gotoworkspace,f.gotoworkspace]]
=== `f.gotoworkspace`

Example of f.function with arg.
